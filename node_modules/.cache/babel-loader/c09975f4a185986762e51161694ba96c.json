{"remainingRequest":"/Users/Mac/Downloads/Omeclone/node_modules/babel-loader/lib/index.js!/Users/Mac/Downloads/Omeclone/node_modules/eslint-loader/index.js??ref--13-0!/Users/Mac/Downloads/Omeclone/src/store/mutations.js","dependencies":[{"path":"/Users/Mac/Downloads/Omeclone/src/store/mutations.js","mtime":1570804640000},{"path":"/Users/Mac/Downloads/Omeclone/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/Mac/Downloads/Omeclone/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/Users/Mac/Downloads/Omeclone/node_modules/eslint-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/web.dom.iterable\";\nimport rootState from \"./state\";\nimport util from \"../util\";\n/**\n * Handles |icecandidate| events by forwarding the specified\n * ICE candidate (created by our local ICE agent) to the other\n * peer through the signaling server.\n */\n\nfunction iceCandidateHandler(event) {\n  if (event.candidate) {\n    util.log('*** Outgoing ICE candidate: ' + event.candidate.candidate);\n    rootState.socket.emit('new-ice-candidate', event.candidate);\n  }\n}\n/**\n * Handle |iceconnectionstatechange| events. This will detect\n * when the ICE connection is closed, failed, or disconnected.\n * This is called when the state of the ICE agent changes.\n */\n\n\nfunction iceConnectionStateChangeHandler(event) {\n  util.log('*** ICE connection state changed to ' + event.target.iceConnectionState);\n\n  switch (event.target.iceConnectionState) {\n    case 'connected':\n    case 'complete':\n      rootState.connectionState = 'open';\n      break;\n\n    case 'closed':\n    case 'failed':\n    case 'disconnected':\n      closeVideoCall();\n      break;\n  }\n}\n/**\n * Handle the |icegatheringstatechange| event. This lets us know what the\n * ICE engine is currently working on: \"new\" means no networking has happened\n * yet, \"gathering\" means the ICE engine is currently gathering candidates,\n * and \"complete\" means gathering is complete. Note that the engine can\n * alternate between \"gathering\" and \"complete\" repeatedly as needs and\n * circumstances change.\n */\n\n\nfunction iceGatheringStateChangeHandler(event) {\n  util.log('*** ICE gathering state changed to: ' + event.target.iceGatheringState);\n}\n/**\n * Set up a |signalingstatechange| event handler. This will detect when\n * the signaling connection is closed.\n */\n\n\nfunction signalingStateChangeHandler(event) {\n  util.log('*** WebRTC signaling state changed to: ' + event.target.signalingState);\n\n  switch (event.target.signalingState) {\n    case 'closed':\n      closeVideoCall();\n      break;\n  }\n}\n/**\n * Called by the WebRTC layer to let us know when it's time to\n * begin, resume, or restart ICE negotiation.\n */\n\n\nfunction negotiationNeededHandler(event) {\n  util.log('*** Negotiation needed');\n\n  if (rootState.connectionState === 'closed') {\n    rootState.connectionState = 'connecting';\n    rootState.socket.emit('search-peer');\n  }\n}\n/**\n * Called by the WebRTC layer when events occur on the media tracks\n * on our WebRTC call. This includes when streams are added to and\n * removed from the call.\n *\n * track events include the following fields:\n * RTCRtpReceiver       receiver\n * MediaStreamTrack     track\n * MediaStream[]        streams\n * RTCRtpTransceiver    transceiver\n *\n * In our case, we're just taking the first stream found and attaching\n * it to the <video> element for incoming media.\n */\n\n\nfunction trackHandler(event) {\n  util.log('*** the remote peer adds a track to the connection');\n  rootState.remoteStream = event.streams[0];\n}\n\nfunction removeTrackHandler(event) {\n  util.log('*** the remote peer removes a track from the connection');\n  var trackList = rootState.remoteStream.getTracks();\n\n  if (trackList.length === 0) {\n    closeVideoCall();\n  }\n}\n/**\n * Close the RTCPeerConnection and reset variables so that the user can\n * make or receive another call if they wish. This is called both\n * when the user hangs up, the other user hangs up, or if a connection\n * failure is detected.\n */\n\n\nfunction closeVideoCall() {\n  rootState.connectionState = 'closed';\n\n  if (!rootState.peerConnection) {\n    return;\n  }\n\n  util.log('Closing the peer connection...'); // Disconnect all our event listeners; we don't want stray events\n  // to interfere with the hangup while it's ongoing.\n\n  rootState.peerConnection.removeEventListener('icecandidate', iceCandidateHandler);\n  rootState.peerConnection.removeEventListener('iceconnectionstatechange', iceConnectionStateChangeHandler);\n  rootState.peerConnection.removeEventListener('icegatheringstatechange', iceGatheringStateChangeHandler);\n  rootState.peerConnection.removeEventListener('signalingstatechange', signalingStateChangeHandler);\n  rootState.peerConnection.removeEventListener('negotiationneeded', negotiationNeededHandler);\n  rootState.peerConnection.removeEventListener('track', trackHandler);\n  rootState.peerConnection.removeEventListener('removetrack ', removeTrackHandler);\n\n  if (rootState.remoteStream) {\n    rootState.remoteStream.getTracks().forEach(function (track) {\n      track.stop();\n    });\n    rootState.remoteStream = null;\n  }\n\n  rootState.peerConnection.close();\n  rootState.peerConnection = null;\n}\n\nexport default {\n  addLocalStream: function addLocalStream(state, stream) {\n    state.localStream = stream;\n    state.localStream.getTracks().forEach(function (track) {\n      state.peerConnection.addTrack(track, state.localStream);\n    });\n  },\n  removeLocalStream: function removeLocalStream(state) {\n    state.localStream.getTracks().forEach(function (track) {\n      return track.stop();\n    });\n    state.localStream = null;\n  },\n  createPeerConnection: function createPeerConnection(state) {\n    util.log('Setting up a connection...');\n    state.peerConnection = new RTCPeerConnection(null);\n    state.peerConnection.addEventListener('icecandidate', iceCandidateHandler);\n    state.peerConnection.addEventListener('iceconnectionstatechange', iceConnectionStateChangeHandler);\n    state.peerConnection.addEventListener('icegatheringstatechange', iceGatheringStateChangeHandler);\n    state.peerConnection.addEventListener('signalingstatechange', signalingStateChangeHandler);\n    state.peerConnection.addEventListener('negotiationneeded', negotiationNeededHandler);\n    state.peerConnection.addEventListener('track', trackHandler);\n    state.peerConnection.addEventListener('removetrack ', removeTrackHandler);\n  },\n  closePeerConnection: function closePeerConnection(state) {\n    closeVideoCall();\n    state.messages.splice(0);\n  },\n  toggleCanvas: function toggleCanvas(state) {\n    state.isCanvasShown = !state.isCanvasShown;\n  },\n  setRemoteCanvas: function setRemoteCanvas(state, remoteCanvas) {\n    state.remoteCanvas = remoteCanvas;\n  },\n  clearMessages: function clearMessages(state) {\n    state.messages.splice(0);\n  },\n  addMessage: function addMessage(state, message) {\n    state.messages.push(message);\n  }\n};",{"version":3,"sources":["/Users/Mac/Downloads/Omeclone/src/store/mutations.js"],"names":["rootState","util","iceCandidateHandler","event","candidate","log","socket","emit","iceConnectionStateChangeHandler","target","iceConnectionState","connectionState","closeVideoCall","iceGatheringStateChangeHandler","iceGatheringState","signalingStateChangeHandler","signalingState","negotiationNeededHandler","trackHandler","remoteStream","streams","removeTrackHandler","trackList","getTracks","length","peerConnection","removeEventListener","forEach","track","stop","close","addLocalStream","state","stream","localStream","addTrack","removeLocalStream","createPeerConnection","RTCPeerConnection","addEventListener","closePeerConnection","messages","splice","toggleCanvas","isCanvasShown","setRemoteCanvas","remoteCanvas","clearMessages","addMessage","message","push"],"mappings":"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","sourcesContent":["import rootState from './state'\nimport util from '../util'\n\n/**\n * Handles |icecandidate| events by forwarding the specified\n * ICE candidate (created by our local ICE agent) to the other\n * peer through the signaling server.\n */\nfunction iceCandidateHandler (event) {\n  if (event.candidate) {\n    util.log('*** Outgoing ICE candidate: ' + event.candidate.candidate)\n    rootState.socket.emit('new-ice-candidate', event.candidate)\n  }\n}\n\n/**\n * Handle |iceconnectionstatechange| events. This will detect\n * when the ICE connection is closed, failed, or disconnected.\n * This is called when the state of the ICE agent changes.\n */\nfunction iceConnectionStateChangeHandler (event) {\n  util.log('*** ICE connection state changed to ' + event.target.iceConnectionState)\n\n  switch (event.target.iceConnectionState) {\n    case 'connected':\n    case 'complete':\n      rootState.connectionState = 'open'\n      break\n    case 'closed':\n    case 'failed':\n    case 'disconnected':\n      closeVideoCall()\n      break\n  }\n}\n\n/**\n * Handle the |icegatheringstatechange| event. This lets us know what the\n * ICE engine is currently working on: \"new\" means no networking has happened\n * yet, \"gathering\" means the ICE engine is currently gathering candidates,\n * and \"complete\" means gathering is complete. Note that the engine can\n * alternate between \"gathering\" and \"complete\" repeatedly as needs and\n * circumstances change.\n */\nfunction iceGatheringStateChangeHandler (event) {\n  util.log('*** ICE gathering state changed to: ' + event.target.iceGatheringState)\n}\n\n/**\n * Set up a |signalingstatechange| event handler. This will detect when\n * the signaling connection is closed.\n */\nfunction signalingStateChangeHandler (event) {\n  util.log('*** WebRTC signaling state changed to: ' + event.target.signalingState)\n\n  switch (event.target.signalingState) {\n    case 'closed':\n      closeVideoCall()\n      break\n  }\n}\n\n/**\n * Called by the WebRTC layer to let us know when it's time to\n * begin, resume, or restart ICE negotiation.\n */\nfunction negotiationNeededHandler (event) {\n  util.log('*** Negotiation needed')\n\n  if (rootState.connectionState === 'closed') {\n    rootState.connectionState = 'connecting'\n    rootState.socket.emit('search-peer')\n  }\n}\n\n/**\n * Called by the WebRTC layer when events occur on the media tracks\n * on our WebRTC call. This includes when streams are added to and\n * removed from the call.\n *\n * track events include the following fields:\n * RTCRtpReceiver       receiver\n * MediaStreamTrack     track\n * MediaStream[]        streams\n * RTCRtpTransceiver    transceiver\n *\n * In our case, we're just taking the first stream found and attaching\n * it to the <video> element for incoming media.\n */\nfunction trackHandler (event) {\n  util.log('*** the remote peer adds a track to the connection')\n  rootState.remoteStream = event.streams[0]\n}\n\nfunction removeTrackHandler (event) {\n  util.log('*** the remote peer removes a track from the connection')\n  const trackList = rootState.remoteStream.getTracks()\n  if (trackList.length === 0) {\n    closeVideoCall()\n  }\n}\n\n/**\n * Close the RTCPeerConnection and reset variables so that the user can\n * make or receive another call if they wish. This is called both\n * when the user hangs up, the other user hangs up, or if a connection\n * failure is detected.\n */\nfunction closeVideoCall () {\n  rootState.connectionState = 'closed'\n\n  if (!rootState.peerConnection) {\n    return\n  }\n\n  util.log('Closing the peer connection...')\n\n  // Disconnect all our event listeners; we don't want stray events\n  // to interfere with the hangup while it's ongoing.\n  rootState.peerConnection.removeEventListener('icecandidate', iceCandidateHandler)\n  rootState.peerConnection.removeEventListener('iceconnectionstatechange', iceConnectionStateChangeHandler)\n  rootState.peerConnection.removeEventListener('icegatheringstatechange', iceGatheringStateChangeHandler)\n  rootState.peerConnection.removeEventListener('signalingstatechange', signalingStateChangeHandler)\n  rootState.peerConnection.removeEventListener('negotiationneeded', negotiationNeededHandler)\n  rootState.peerConnection.removeEventListener('track', trackHandler)\n  rootState.peerConnection.removeEventListener('removetrack ', removeTrackHandler)\n\n  if (rootState.remoteStream) {\n    rootState.remoteStream.getTracks().forEach(track => {\n      track.stop()\n    })\n    rootState.remoteStream = null\n  }\n\n  rootState.peerConnection.close()\n  rootState.peerConnection = null\n}\n\nexport default {\n  addLocalStream (state, stream) {\n    state.localStream = stream\n    state.localStream.getTracks().forEach(track => {\n      state.peerConnection.addTrack(track, state.localStream)\n    })\n  },\n\n  removeLocalStream (state) {\n    state.localStream.getTracks().forEach(track => track.stop())\n    state.localStream = null\n  },\n\n  createPeerConnection (state) {\n    util.log('Setting up a connection...')\n    state.peerConnection = new RTCPeerConnection(null)\n    state.peerConnection.addEventListener('icecandidate', iceCandidateHandler)\n    state.peerConnection.addEventListener('iceconnectionstatechange', iceConnectionStateChangeHandler)\n    state.peerConnection.addEventListener('icegatheringstatechange', iceGatheringStateChangeHandler)\n    state.peerConnection.addEventListener('signalingstatechange', signalingStateChangeHandler)\n    state.peerConnection.addEventListener('negotiationneeded', negotiationNeededHandler)\n    state.peerConnection.addEventListener('track', trackHandler)\n    state.peerConnection.addEventListener('removetrack ', removeTrackHandler)\n  },\n\n  closePeerConnection (state) {\n    closeVideoCall()\n    state.messages.splice(0)\n  },\n\n  toggleCanvas (state) {\n    state.isCanvasShown = !state.isCanvasShown\n  },\n\n  setRemoteCanvas (state, remoteCanvas) {\n    state.remoteCanvas = remoteCanvas\n  },\n\n  clearMessages (state) {\n    state.messages.splice(0)\n  },\n\n  addMessage (state, message) {\n    state.messages.push(message)\n  }\n}\n"]}]}